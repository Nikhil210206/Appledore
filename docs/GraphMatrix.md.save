.# **📌 Overview**
<<<<<<< HEAD

``GraphMatrix.h`` is a header file that defines the GraphMatrix class, which represents a graph using an adjacency matrix. This data structure is useful for graph-related operations such as:

- Adding and removing vertices and edges
- Retrieving connectivity information
- Efficient traversal and manipulation of graph data


**🔹 Key Features**
Adjacency Matrix Representation: Uses a 1D matrix flattened as 2D matrix to store edges.
Supports Weighted and Unweighted Graphs along: Can handle edge weights efficiently.
Template-based Design: Allows customization of vertex and edge types.

# **📌 Structure of GraphMatrix.h**

### **🔹 Templates Used**
```cpp
template <typename VertexType, typename EdgeType>
class GraphMatrix {}
```
VertexType: Represents the type of vertices (e.g., int, std::string).
EdgeType: Represents the type of edge weights (int, double, etc.).

### **🔹 Class Definition**
```cpp
template <typename VertexType, typename EdgeType>
class GraphMatrix {
private:

=======

`GraphMatrix.h` defines the `GraphMatrix` class, which represents a graph using an adjacency matrix. This data structure is useful for various graph operations, including:

- **Adding and Removing Vertices and Edges**  
- **Efficient Edge Retrieval and Modification**  
- **Graph Traversals (DFS, BFS) and Algorithms (Shortest Path, MST, etc.)**  

**🔹 Key Features**  

✅ **Adjacency Matrix Representation:** Uses a **1D vector** (flattened view of a **2D matrix**) to store graph connectivity.  
✅ **Supports Directed & Undirected Graphs:** Graphs can be explicitly directed or undirected.  
✅ **Weighted & Unweighted Graphs:** Can handle edges with or without weights.  
✅ **Template-based Design:** Allows custom vertex and edge types for flexibility.

---

# **📌 Structure of `GraphMatrix.h`**

## **🔹 Templates Used**
template <typename VertexType, typename EdgeType>
class GraphMatrix {}
VertexType: Defines the type of vertices (e.g., int, std::string).
EdgeType: Defines the type of edge weights (int, double, etc.).

🔹 Class Definition:
template <typename VertexType, typename EdgeType>
class GraphMatrix {
private:
>>>>>>> b5b92d2 (Modified)
    std::map<VertexType, size_t> vertexToIndex;
    std::vector<VertexType> indexToVertex;
    std::vector<std::optional<EdgeInfo<EdgeType>>> adjacencyMatrix;
    size_t numVertices = 0;
    bool isDirected;
    bool isWeighted;
public:
    void addVertex(const VertexType& vertex);
    void addEdge(const VertexType& src, const VertexType& dest, EdgeType weight);
    bool hasEdge(const VertexType& src, const VertexType& dest);
    EdgeType getEdgeValue(const VertexType& src, const VertexType& dest);
    std::vector<VertexType> getNeighbors(const VertexType& vertex);
    ...
};
```
# **🔹 Important Components**
### 1. **adjacencyMatrix**
The ``adjacencyMatrix`` is a 1-Dimensional Vector that is being viewed as a 2-Dimensional vector by using a formula to calculate offsets to store values. Each value in the ``adjacencyMatrix`` is a ``std::optional`` value which means each element can have a value of ``EdgeInfo`` struct type or each element can be a ``std::nullopt`` signifying that there is no value present.

<<<<<<< HEAD
=======
📌 Important Components:

1️⃣ adjacencyMatrix
Representation: A 1D vector viewed as a 2D adjacency matrix.
Data Type: std::optional<EdgeInfo<EdgeType>>
Purpose: Stores edges efficiently using index-based access.
Index Calculation: Uses a helper function getIndex(i, j) to convert 2D indices (i, j) into a 1D index.

inline size_t getIndex(size_t i, size_t j) const {
    return i * numVertices + j;
}
Allows flattening and efficient memory access.

🔹 Visual Representation of adjacencyMatrix:

1D Representation:
[ 0,  5, ∞, 10,  ∞, ∞, 2,  ∞, 7 ]

Flattened into 2D Matrix (numVertices × numVertices):
   A   B   C  
A [ 0   5   ∞ ]  
B [ 10  ∞   ∞ ]  
C [ 2   ∞   7 ]  

✅ Efficiently stores edge weights
✅ Fast index-based access

📌 Diagram:

2️⃣ numVertices
Purpose: Stores the current count of vertices in the graph.
3️⃣ isDirected & isWeighted
isDirected → true if the graph is directed.
isWeighted → true if the graph has weighted edges.
4️⃣ vertexToIndex
Type: std::map<VertexType, size_t>
Purpose: Maps each vertex to its corresponding index in the adjacency matrix.
5️⃣ indexToVertex
Type: std::vector<VertexType>
Purpose: Maps each index back to its original vertex.
Use Case: Converts numeric indices back into their original vertex representation.
📌 Diagram:
>>>>>>> b5b92d2 (Modified)

### 2. **``numVertices``**
This variable is maintained as private member to indicate the number of vertices which are currently present in a graph.

### 3. ``isDirected`` and ``isWeighted``
These two variables are also private, they are used to determine about the directionality and weightedness of a graph.

### 4. **vertexToIndex** 
Maps a vertex to its corresponding index for faster lookups using a ``std::map``.
### 5. **indexToVertex**  
Maps a index to each of the vertex in the order they are inserted.

### How are ``indexToVertex`` and ``vertexToIndex`` related?
Consider a graph as empty, and suppose if you add a vertex **"A"** the vertex is first added to the last index of the ``indexToVertex`` in this case the **"A"** is saved at 0th index. And in ``vertexToIndex`` the integer index corresponding to vertex **"A"** is 0.


# 📌 How GraphMatrix.h Works

1️⃣ Adding a Vertex
Assigns an index to the vertex.
Expands adjacencyMatrix to accommodate new vertex connections.
2️⃣ Adding an Edge
Converts vertex names into numeric indices using vertexToIndex.
Stores the edge weight in adjacencyMatrix using getIndex(i, j).
3️⃣ Retrieving Neighbors
Uses adjacencyMatrix to check which indices contain non-null values.
Converts numeric indices back to vertex names using indexToVertex.

📌 Connections to Other Files

🔹 Dependencies
1️⃣ MixedGraph.h → Extends GraphMatrix.h to support mixed graphs.
2️⃣ GraphAlgorithms.h → Implements BFS, DFS, Shortest Path, etc.

🔹 Interaction with Other Components: 
✅ GraphMatrix.h serves as the base data structure for all graph operations.
✅ Used extensively in graph algorithms and specialized graph representations.

📌 Visual Representation:
1. A simple graph with mixed directed and undirected edges: 
![Pic 1](assets/1.webp)

2. Adjacency Matrix Representation (1D to 2D conversion): 
![Pic 2](assets/2.webp)

3. ertex Mapping (vertexToIndex and indexToVertex): 
![Pic 3](assets/3.webp)

4.Flattening a 1D Vector into 2D using getIndex function diagram: 
 ![Pic 4](assets/4.png)

📌 Available Methods: 
void addVertex(const VertexType& vertex);
void addEdge(const VertexType& src, const VertexType& dest, EdgeType weight);
bool hasEdge(const VertexType& src, const VertexType& dest);
EdgeType getEdgeValue(const VertexType& src, const VertexType& dest);
std::vector<VertexType> getNeighbors(const VertexType& vertex);

